{"version":3,"sources":["orbit-common.js","orbit-common/cache.js","orbit-common/lib/exceptions.js","orbit-common/main.js","orbit-common/memory-source.js","orbit-common/schema.js","orbit-common/serializer.js","orbit-common/source.js"],"sourcesContent":["define('orbit-common', ['exports', 'orbit-common/main', 'orbit-common/cache', 'orbit-common/schema', 'orbit-common/serializer', 'orbit-common/source', 'orbit-common/memory-source', 'orbit-common/lib/exceptions'], function (exports, OC, Cache, Schema, Serializer, Source, MemorySource, exceptions) {\n\n\t'use strict';\n\n\tOC['default'].Cache = Cache['default'];\n\tOC['default'].Schema = Schema['default'];\n\tOC['default'].Serializer = Serializer['default'];\n\tOC['default'].Source = Source['default'];\n\tOC['default'].MemorySource = MemorySource['default'];\n\t// exceptions\n\tOC['default'].OperationNotAllowed = exceptions.OperationNotAllowed;\n\tOC['default'].RecordNotFoundException = exceptions.RecordNotFoundException;\n\tOC['default'].LinkNotFoundException = exceptions.LinkNotFoundException;\n\tOC['default'].RecordAlreadyExistsException = exceptions.RecordAlreadyExistsException;\n\n\texports['default'] = OC['default'];\n\n});","define('orbit-common/cache', ['exports', 'orbit/document', 'orbit/evented', 'orbit/operation', 'orbit/lib/objects', 'orbit-common/lib/exceptions', 'orbit/lib/eq', 'orbit/lib/deprecate'], function (exports, Document, Evented, Operation, objects, exceptions, eq, deprecate) {\n\n  'use strict';\n\n  var Cache = objects.Class.extend({\n    init: function(schema, options) {\n      options = options || {};\n\n      if (options.trackRevLinks !== undefined && options.maintainRevLinks === undefined) {\n        deprecate.deprecate('Please convert usage of the Cache option `trackRevLinks` to `maintainRevLinks`.');\n        options.maintainRevLinks = options.trackRevLinks;\n      }\n\n      this.trackChanges = options.trackChanges !== undefined ? options.trackChanges : true;\n      this.maintainRevLinks = options.maintainRevLinks !== undefined ? options.maintainRevLinks : true;\n      this.trackRevLinkChanges = options.trackRevLinkChanges !== undefined ? options.trackRevLinkChanges : false;\n      this.maintainInverseLinks = options.maintainInverseLinks !== undefined ? options.maintainRevLinks : true;\n      this.maintainDependencies = options.maintainDependencies !== undefined ? options.maintainDependencies : true;\n\n      this._doc = new Document['default'](null, {arrayBasedPaths: true});\n\n      this._pathsToRemove = [];\n\n      Evented['default'].extend(this);\n\n      this.schema = schema;\n      for (var model in schema.models) {\n        if (schema.models.hasOwnProperty(model)) {\n          this._registerModel(model);\n        }\n      }\n\n      // TODO - clean up listener\n      this.schema.on('modelRegistered', this._registerModel, this);\n    },\n\n    _registerModel: function(model) {\n      var modelRootPath = [model];\n      if (!this.retrieve(modelRootPath)) {\n        this._doc.add(modelRootPath, {});\n      }\n    },\n\n    reset: function(data) {\n      this._doc.reset(data);\n      this.schema.registerAllKeys(data);\n    },\n\n    /**\n     Return the size of data at a particular path\n\n     @method length\n     @param path\n     @returns {Number}\n     */\n    length: function(path) {\n      var data = this.retrieve(path);\n      if (data === null || data === undefined) {\n        return data;\n      } else if (objects.isArray(data)) {\n        return data.length;\n      } else {\n        return Object.keys(data).length;\n      }\n    },\n\n    /**\n     Return data at a particular path.\n\n     Returns `null` if the path does not exist in the document.\n\n     @method retrieve\n     @param path\n     @returns {Object}\n     */\n    retrieve: function(path) {\n      try {\n        // console.log('Cache#retrieve', path, this._doc.retrieve(path));\n        return this._doc.retrieve(path);\n      } catch(e) {\n        return undefined;\n      }\n    },\n\n    /**\n     * Retrieves a link value.  Returns a null value for empty links.\n     * For hasOne links will return a string id value of the link.\n     * For hasMany links will return an array of id values.\n     *\n     * @param  {String} type Model Type.\n     * @param  {String} id   Model ID.\n     * @param  {String} link Link Key.\n     * @return {Array|String|null}      The value of the link\n     */\n    retrieveLink: function(type, id, link) {\n      var val = this.retrieve([type, id, '__rel', link]);\n      if (val !== null && typeof val === 'object') {\n        val = Object.keys(val);\n      }\n      return val;\n    },\n\n\n    /**\n     Returns whether a path exists in the document.\n\n     @method exists\n     @param path\n     @returns {Boolean}\n     */\n    exists: function(path) {\n      try {\n        this._doc.retrieve(path);\n        return true;\n      } catch(e) {\n        return false;\n      }\n    },\n\n    /**\n     Transforms the document with an RFC 6902-compliant operation.\n\n     Currently limited to `add`, `remove` and `replace` operations.\n\n     Throws `PathNotFoundException` if the path does not exist in the document.\n\n     @method transform\n     @param {Object} operation\n     @param {String} operation.op Must be \"add\", \"remove\", or \"replace\"\n     @param {Array or String} operation.path Path to target location\n     @param {Object} operation.value Value to set. Required for \"add\" and \"replace\"\n     @returns {Boolean} true if operation is applied or false\n     */\n    transform: function(operation) {\n      var normalizedOperation;\n      if (operation instanceof Operation['default']) {\n        normalizedOperation = operation;\n      } else {\n        normalizedOperation = new Operation['default'](operation);\n      }\n\n      var op = normalizedOperation.op;\n      var path = normalizedOperation.path;\n      var value = normalizedOperation.value;\n      var currentValue = this.retrieve(path);\n      var _this = this;\n      var inverse;\n\n      // console.log('Cache#transform', op, path.join('/'), value);\n\n      if (op !== 'add' && op !== 'remove' && op !== 'replace') {\n        throw new exceptions.OperationNotAllowed('Cache#transform requires an \"add\", \"remove\" or \"replace\" operation.');\n      }\n\n      if (path.length < 2) {\n        throw new exceptions.OperationNotAllowed('Cache#transform requires an operation with a path >= 2 segments.');\n      }\n\n      if (op === 'add' || op === 'replace') {\n        if (!this.exists(path.slice(0, path.length - 1))) {\n          return false;\n        }\n\n      } else if (op === 'remove') {\n        if (this._isMarkedForRemoval(path)) {\n          // console.log('remove op not required because marked for removal', path);\n          return false;\n        }\n      }\n\n      if (eq.eq(currentValue, value)) return false;\n\n      if (path.length > 2 && path[2] === '__rev') {\n        // Apply reverse link transform\n        if (this.trackRevLinkChanges) {\n          inverse = this._doc.transform(normalizedOperation, true);\n          this.emit('didTransform', normalizedOperation, inverse);\n\n        } else {\n          this._doc.transform(normalizedOperation, false);\n        }\n\n      } else {\n        var dependentOperations;\n\n        if (this.maintainDependencies) {\n          dependentOperations = this._transformDependencies(normalizedOperation);\n        }\n\n        if (op === 'remove' || op === 'replace') {\n          this._markForRemoval(path);\n\n          if (this.maintainInverseLinks) {\n            if (op === 'replace') {\n              this._transformRelatedInverseLinks(normalizedOperation.spawn({\n                op: 'remove',\n                path: path\n              }));\n            }\n\n            this._transformRelatedInverseLinks(normalizedOperation);\n          }\n\n          if (this.maintainRevLinks) {\n            this._removeRevLinks(path, normalizedOperation);\n          }\n        }\n\n        if (this.trackChanges) {\n          inverse = this._doc.transform(normalizedOperation, true);\n          this.emit('didTransform',\n                    normalizedOperation,\n                    inverse);\n\n        } else {\n          this._doc.transform(normalizedOperation, false);\n        }\n\n        if (op === 'remove' || op === 'replace') {\n          this._unmarkForRemoval(path);\n        }\n\n        if (op === 'add' || op === 'replace') {\n          if (this.maintainRevLinks) {\n            this._addRevLinks(path, value, normalizedOperation);\n          }\n\n          if (this.maintainInverseLinks) {\n            if (op === 'replace') {\n              this._transformRelatedInverseLinks(normalizedOperation.spawn({\n                op: 'add',\n                path: path,\n                value: value\n              }));\n\n            } else {\n              this._transformRelatedInverseLinks(normalizedOperation);\n            }\n          }\n        }\n\n        if (dependentOperations) {\n          dependentOperations.forEach(function(operation) {\n            _this.transform(operation);\n          });\n        }\n      }\n\n      return true;\n    },\n\n    _markForRemoval: function(path) {\n      path = path.join('/');\n      // console.log('_markForRemoval', path);\n      this._pathsToRemove.push(path);\n    },\n\n    _unmarkForRemoval: function(path) {\n      path = path.join('/');\n      var i = this._pathsToRemove.indexOf(path);\n      // console.log('_unmarkForRemoval', path, i);\n      if (i > -1) this._pathsToRemove.splice(i, 1);\n    },\n\n    _isMarkedForRemoval: function(path) {\n      path = path.join('/');\n      // console.log('_isMarkedForRemoval', path);\n      return (this._pathsToRemove.indexOf(path) > -1);\n    },\n\n    _isOperationRequired: function(operation) {\n      if (operation.op === 'remove') {\n        if (this._isMarkedForRemoval(operation.path)) {\n          console.log('remove op not required because marked for removal', operation.path);\n          return false;\n        }\n      }\n\n      var currentValue = this.retrieve(operation.path);\n      var desiredValue = operation.value;\n\n      console.log('op required', !eq.eq(currentValue, desiredValue), operation);\n\n      return !eq.eq(currentValue, desiredValue);\n    },\n\n    _transformDependencies: function(operation) {\n      var operations = [];\n      if (operation.op === 'remove' && operation.path.length === 2) {\n        var _this = this,\n          type = operation.path[0],\n          id = operation.path[1],\n          links = _this.schema.models[type].links;\n\n        Object.keys(links).forEach(function(link) {\n          var linkSchema = links[link];\n          if (linkSchema.dependent !== 'remove') {\n            return;\n          }\n\n          var linkValue = _this.retrieveLink(type, id, link);\n          if (linkValue) {\n            [].concat(linkValue).forEach(function(value) {\n              var dependentPath = [linkSchema.model, value];\n              if (_this.retrieve(dependentPath)) {\n                operations.push(operation.spawn({\n                  op: 'remove',\n                  path: dependentPath\n                }));\n              }\n            });\n          }\n        });\n\n      }\n\n      return operations;\n    },\n\n    _addRevLinks: function(path, value, parentOperation) {\n      // console.log('_addRevLinks', path, value);\n\n      if (value) {\n        var _this = this,\n            type = path[0],\n            id = path[1],\n            linkSchema,\n            linkValue;\n\n        if (path.length === 2) {\n          // when a whole record is added, add inverse links for every link\n          if (value.__rel) {\n            Object.keys(value.__rel).forEach(function(link) {\n              linkSchema = _this.schema.models[type].links[link];\n              linkValue = value.__rel[link];\n\n              if (linkSchema.type === 'hasMany') {\n                Object.keys(linkValue).forEach(function(v) {\n                  _this._addRevLink(linkSchema, type, id, link, v, parentOperation);\n                });\n\n              } else {\n                _this._addRevLink(linkSchema, type, id, link, linkValue, parentOperation);\n              }\n            });\n          }\n\n        } else if (path.length > 3) {\n          var link = path[3];\n\n          linkSchema = _this.schema.models[type].links[link];\n\n          if (path.length === 5) {\n            linkValue = path[4];\n          } else {\n            linkValue = value;\n          }\n\n          this._addRevLink(linkSchema, type, id, link, linkValue, parentOperation);\n        }\n      }\n    },\n\n    _addRevLink: function(linkSchema, type, id, link, value, parentOperation) {\n      // console.log('_addRevLink', linkSchema, type, id, link, value);\n\n      if (value && typeof value === 'string') {\n        var linkPath = [type, id, '__rel', link];\n        if (linkSchema.type === 'hasMany') {\n          linkPath.push(value);\n        }\n        linkPath = linkPath.join('/');\n\n        var refsPath = [linkSchema.model, value, '__rev'];\n        var refs = this.retrieve(refsPath);\n        if (!refs) {\n          refs = {};\n          refs[linkPath] = true;\n          this.transform(parentOperation.spawn({\n            op: 'add',\n            path: refsPath,\n            value: refs\n          }));\n\n        } else {\n          refsPath.push(linkPath);\n          refs = this.retrieve(refsPath);\n          if (!refs) {\n            this.transform(parentOperation.spawn({\n              op: 'add',\n              path: refsPath,\n              value: true\n            }));\n          }\n        }\n      }\n    },\n\n    _removeRevLinks: function(path, parentOperation) {\n      // console.log('_removeRevLinks', path);\n\n      var value = this.retrieve(path);\n      if (value) {\n        var _this = this,\n            type = path[0],\n            id = path[1],\n            linkSchema,\n            linkValue;\n\n        if (path.length === 2) {\n          // when a whole record is removed, remove any links that reference it\n          if (value.__rev) {\n            // console.log('removeRefs from deleted record', type, id, value.__rev);\n\n            var operation;\n            Object.keys(value.__rev).forEach(function(path) {\n              path = _this._doc.deserializePath(path);\n\n              if (path.length === 4) {\n                operation = parentOperation.spawn({\n                  op: 'replace',\n                  path: path,\n                  value: null\n                });\n              } else {\n                operation = parentOperation.spawn({\n                  op: 'remove',\n                  path: path\n                });\n              }\n\n              _this.transform(operation);\n            });\n          }\n\n          // when a whole record is removed, remove references corresponding to each link\n          if (value.__rel) {\n            Object.keys(value.__rel).forEach(function(link) {\n              linkSchema = _this.schema.models[type].links[link];\n              linkValue = value.__rel[link];\n\n              if (linkSchema.type === 'hasMany') {\n                Object.keys(linkValue).forEach(function(v) {\n                  _this._removeRevLink(linkSchema, type, id, link, v, parentOperation);\n                });\n\n              } else {\n                _this._removeRevLink(linkSchema, type, id, link, linkValue, parentOperation);\n              }\n            });\n          }\n\n        } else if (path.length > 3) {\n          var link = path[3];\n\n          linkSchema = _this.schema.models[type].links[link];\n\n          if (path.length === 5) {\n            linkValue = path[4];\n          } else {\n            linkValue = value;\n          }\n\n          this._removeRevLink(linkSchema, type, id, link, linkValue, parentOperation);\n        }\n      }\n    },\n\n    _removeRevLink: function(linkSchema, type, id, link, value, parentOperation) {\n      // console.log('_removeRevLink', linkSchema, type, id, link, value);\n\n      if (value && typeof value === 'string') {\n        var linkPath = [type, id, '__rel', link];\n        if (linkSchema.type === 'hasMany') {\n          linkPath.push(value);\n        }\n        linkPath = linkPath.join('/');\n\n        this.transform(parentOperation.spawn({\n          op: 'remove',\n          path: [linkSchema.model, value, '__rev', linkPath]\n        }));\n      }\n    },\n\n    _transformRelatedInverseLinks: function(operation) {\n      var _this = this;\n      var op = operation.op;\n      var path = operation.path;\n      var value = operation.value;\n      var type = path[0];\n      var record;\n      var key;\n      var linkDef;\n      var linkValue;\n      var inverseLinkOp;\n      var relId;\n\n      if (op === 'add') {\n        if (path.length > 3 && path[2] === '__rel') {\n\n          key = path[3];\n          linkDef = this.schema.models[type].links[key];\n\n          if (linkDef.inverse) {\n            if (path.length > 4) {\n              relId = path[4];\n            } else {\n              relId = value;\n            }\n\n            if (objects.isObject(relId)) {\n              Object.keys(relId).forEach(function(id) {\n                _this._transformAddLink(\n                  linkDef.model,\n                  id,\n                  linkDef.inverse,\n                  path[1],\n                  operation\n                );\n              });\n\n            } else {\n              _this._transformAddLink(\n                linkDef.model,\n                relId,\n                linkDef.inverse,\n                path[1],\n                operation\n              );\n            }\n          }\n\n        } else if (path.length === 2) {\n\n          record = operation.value;\n          if (record.__rel) {\n            Object.keys(record.__rel).forEach(function(key) {\n              linkDef = _this.schema.models[type].links[key];\n\n              if (linkDef.inverse) {\n                if (linkDef.type === 'hasMany') {\n                  Object.keys(record.__rel[key]).forEach(function(id) {\n                    _this._transformAddLink(\n                      linkDef.model,\n                      id,\n                      linkDef.inverse,\n                      path[1],\n                      operation\n                    );\n                  });\n\n                } else {\n                  var id = record.__rel[key];\n\n                  if (!objects.isNone(id)) {\n                    _this._transformAddLink(\n                      linkDef.model,\n                      id,\n                      linkDef.inverse,\n                      path[1],\n                      operation\n                    );\n                  }\n                }\n              }\n            });\n          }\n        }\n\n      } else if (op === 'remove') {\n\n        if (path.length > 3 && path[2] === '__rel') {\n\n          key = path[3];\n          linkDef = this.schema.models[type].links[key];\n\n          if (linkDef.inverse) {\n            if (path.length > 4) {\n              relId = path[4];\n            } else {\n              relId = this.retrieve(path);\n            }\n\n            if (relId) {\n              if (objects.isObject(relId)) {\n                Object.keys(relId).forEach(function(id) {\n                  _this._transformRemoveLink(\n                    linkDef.model,\n                    id,\n                    linkDef.inverse,\n                    path[1],\n                    operation\n                  );\n                });\n\n              } else {\n                _this._transformRemoveLink(\n                  linkDef.model,\n                  relId,\n                  linkDef.inverse,\n                  path[1],\n                  operation\n                );\n              }\n            }\n          }\n\n        } else if (path.length === 2) {\n\n          record = this.retrieve(path);\n          if (record.__rel) {\n            Object.keys(record.__rel).forEach(function(key) {\n              linkDef = _this.schema.models[type].links[key];\n\n              if (linkDef.inverse) {\n                if (linkDef.type === 'hasMany') {\n                  Object.keys(record.__rel[key]).forEach(function(id) {\n                    _this._transformRemoveLink(\n                      linkDef.model,\n                      id,\n                      linkDef.inverse,\n                      path[1],\n                      operation\n                    );\n                  });\n\n                } else {\n                  var id = record.__rel[key];\n\n                  if (!objects.isNone(id)) {\n                    _this._transformRemoveLink(\n                      linkDef.model,\n                      id,\n                      linkDef.inverse,\n                      path[1],\n                      operation\n                    );\n                  }\n                }\n              }\n            });\n          }\n        }\n      }\n    },\n\n    _transformAddLink: function(type, id, key, value, parentOperation) {\n      // console.log('_transformAddLink', type, id, key, value);\n\n      if (this.retrieve([type, id])) {\n        var op = this._addLinkOp(type, id, key, value);\n\n        // Apply operation only if necessary\n        if (this.retrieve(op.path) !== op.value) {\n          this.transform(parentOperation.spawn(op));\n        }\n      }\n    },\n\n    _transformRemoveLink: function(type, id, key, value, parentOperation) {\n      // console.log('_transformRemoveLink', type, id, key, value);\n\n      var op = this._removeLinkOp(type, id, key, value);\n\n      // Apply operation only if necessary\n      if (this.retrieve(op.path) && !this._isMarkedForRemoval(op.path)) {\n        this.transform(parentOperation.spawn(op));\n      }\n    },\n\n    _transformUpdateLink: function(type, id, key, value, parentOperation) {\n      // console.log('_transformUpdateLink', type, id, key, value);\n\n      if (this.retrieve([type, id])) {\n        var op = this._updateLinkOp(type, id, key, value);\n\n        // Apply operation only if necessary\n        if (this.retrieve(op.path) !== op.value) {\n          this.transform(parentOperation.spawn(op));\n        }\n      }\n    },\n\n    _addLinkOp: function(type, id, key, value) {\n      var linkDef = this.schema.models[type].links[key];\n      var path = [type, id, '__rel', key];\n      var op;\n\n      if (linkDef.type === 'hasMany') {\n        path.push(value);\n        value = true;\n        op = 'add';\n      } else {\n        op = 'replace';\n      }\n\n      return new Operation['default']({\n        op: op,\n        path: path,\n        value: value\n      });\n    },\n\n    _removeLinkOp: function(type, id, key, value) {\n      var linkDef = this.schema.models[type].links[key];\n      var path = [type, id, '__rel', key];\n      var op;\n\n      if (linkDef.type === 'hasMany') {\n        path.push(value);\n        op = 'remove';\n      } else {\n        op = 'replace';\n        value = null;\n      }\n\n      return new Operation['default']({\n        op: op,\n        path: path,\n        value: value\n      });\n    },\n\n    _updateLinkOp: function(type, id, key, value) {\n      var linkDef = this.schema.models[type].links[key];\n      var path = [type, id, '__rel', key];\n\n      if (linkDef.type === 'hasMany' &&\n          objects.isArray(value)) {\n        var obj = {};\n        for (var i = 0, l = value.length; i < l; i++) {\n          obj[value[i]] = true;\n        }\n        value = obj;\n      }\n\n      return new Operation['default']({\n        op: 'replace',\n        path: path,\n        value: value\n      });\n    }\n  });\n\n  exports['default'] = Cache;\n\n});","define('orbit-common/lib/exceptions', ['exports'], function (exports) {\n\n  'use strict';\n\n  /**\n   @module orbit-common\n   */\n\n  /**\n   Exception thrown when an operation is not allowed.\n\n   @class OperationNotAllowed\n   @namespace OC\n   @param {Object} description\n   @constructor\n   */\n  var OperationNotAllowed = function(description) {\n    this.description = description;\n  };\n\n  OperationNotAllowed.prototype = {\n    constructor: OperationNotAllowed\n  };\n\n  /**\n   Exception thrown when a record can not be found.\n\n   @class RecordNotFoundException\n   @namespace OC\n   @param {String} type\n   @param {Object} record\n   @constructor\n   */\n  var RecordNotFoundException = function(type, record) {\n    this.type = type;\n    this.record = record;\n  };\n\n  RecordNotFoundException.prototype = {\n    constructor: RecordNotFoundException\n  };\n\n  /**\n   Exception thrown when a record can not be found.\n\n   @class LinkNotFoundException\n   @namespace OC\n   @param {String} type\n   @param {Object} record\n   @constructor\n   */\n  var LinkNotFoundException = function(type, record, key) {\n    this.type = type;\n    this.record = record;\n    this.key = key;\n  };\n\n  LinkNotFoundException.prototype = {\n    constructor: LinkNotFoundException\n  };\n\n  /**\n   Exception thrown when a record already exists.\n\n   @class RecordAlreadyExistsException\n   @namespace OC\n   @param {String} type\n   @param {Object} record\n   @constructor\n   */\n  var RecordAlreadyExistsException = function(type, record) {\n    this.type = type;\n    this.record = record;\n  };\n\n  RecordAlreadyExistsException.prototype = {\n    constructor: RecordAlreadyExistsException\n  };\n\n  exports.OperationNotAllowed = OperationNotAllowed;\n  exports.RecordNotFoundException = RecordNotFoundException;\n  exports.LinkNotFoundException = LinkNotFoundException;\n  exports.RecordAlreadyExistsException = RecordAlreadyExistsException;\n\n});","define('orbit-common/main', ['exports'], function (exports) {\n\n\t'use strict';\n\n\t/**\n\t The Orbit Common library (namespaced `OC` by default) defines a common set of\n\t compatible sources.\n\n\t The Common library contains a base abstract class, `Source`, which supports\n\t both `Transformable` and `Requestable` interfaces. The method signatures on\n\t `Source` should be supported by other sources that want to be fully compatible\n\t with the Common library.\n\n\t @module orbit-common\n\t @main orbit-common\n\t */\n\n\t/**\n\t Namespace for Orbit Common methods and classes.\n\n\t @class OC\n\t @static\n\t */\n\tvar OC = {};\n\n\texports['default'] = OC;\n\n});","define('orbit-common/memory-source', ['exports', 'orbit/main', 'orbit/lib/assert', 'orbit/lib/objects', 'orbit-common/source', 'orbit-common/lib/exceptions'], function (exports, Orbit, assert, objects, Source, exceptions) {\n\n  'use strict';\n\n  var MemorySource = Source['default'].extend({\n    init: function(schema, options) {\n      assert.assert('MemorySource requires Orbit.Promise to be defined', Orbit['default'].Promise);\n      this._super.apply(this, arguments);\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Transformable interface implementation\n    /////////////////////////////////////////////////////////////////////////////\n\n    _transform: function(operation) {\n      // Transform the cache\n      // Note: the cache's didTransform event will trigger this source's\n      // didTransform event.\n      this._cache.transform(operation);\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Requestable interface implementation\n    /////////////////////////////////////////////////////////////////////////////\n\n    _find: function(type, id) {\n      var _this = this,\n          modelSchema = this.schema.models[type],\n          pk = modelSchema.primaryKey.name,\n          result;\n\n      return new Orbit['default'].Promise(function(resolve, reject) {\n        if (objects.isNone(id)) {\n          result = _this._filter.call(_this, type);\n\n        } else if (objects.isArray(id)) {\n          var res,\n              resId,\n              notFound;\n\n          result = [];\n          notFound = [];\n\n          for (var i = 0, l = id.length; i < l; i++) {\n            resId = id[i];\n\n            res = _this.retrieve([type, resId]);\n\n            if (res) {\n              result.push(res);\n            } else {\n              notFound.push(resId);\n            }\n          }\n\n          if (notFound.length > 0) {\n            result = null;\n            id = notFound;\n          }\n\n        } else if (id !== null && typeof id === 'object') {\n          if (id[pk]) {\n            result = _this.retrieve([type, id[pk]]);\n\n          } else {\n            result = _this._filter.call(_this, type, id);\n          }\n\n        } else {\n          result = _this.retrieve([type, id]);\n        }\n\n        if (result) {\n          resolve(result);\n        } else {\n          reject(new exceptions.RecordNotFoundException(type, id));\n        }\n      });\n    },\n\n    _findLink: function(type, id, link) {\n      var _this = this;\n\n      return new Orbit['default'].Promise(function(resolve, reject) {\n        id = _this.getId(type, id);\n\n        var record = _this.retrieve([type, id]);\n\n        if (record) {\n          var relId;\n\n          if (record.__rel) {\n            relId = record.__rel[link];\n\n            if (relId) {\n              var linkDef = _this.schema.models[type].links[link];\n              if (linkDef.type === 'hasMany') {\n                relId = Object.keys(relId);\n              }\n            }\n          }\n\n          if (relId) {\n            resolve(relId);\n\n          } else {\n            reject(new exceptions.LinkNotFoundException(type, id, link));\n          }\n\n        } else {\n          reject(new exceptions.RecordNotFoundException(type, id));\n        }\n      });\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Internals\n    /////////////////////////////////////////////////////////////////////////////\n\n    _filter: function(type, query) {\n      var all = [],\n          dataForType,\n          i,\n          prop,\n          match,\n          record;\n\n      dataForType = this.retrieve([type]);\n\n      for (i in dataForType) {\n        if (dataForType.hasOwnProperty(i)) {\n          record = dataForType[i];\n          if (query === undefined) {\n            match = true;\n          } else {\n            match = false;\n            for (prop in query) {\n              if (record[prop] === query[prop]) {\n                match = true;\n              } else {\n                match = false;\n                break;\n              }\n            }\n          }\n          if (match) all.push(record);\n        }\n      }\n      return all;\n    },\n\n    _filterOne: function(type, prop, value) {\n      var dataForType,\n          i,\n          record;\n\n      dataForType = this.retrieve([type]);\n\n      for (i in dataForType) {\n        if (dataForType.hasOwnProperty(i)) {\n          record = dataForType[i];\n          if (record[prop] === value) {\n            return record;\n          }\n        }\n      }\n    }\n  });\n\n  exports['default'] = MemorySource;\n\n});","define('orbit-common/schema', ['exports', 'orbit/lib/objects', 'orbit/lib/uuid', 'orbit-common/lib/exceptions', 'orbit/evented'], function (exports, objects, uuid, exceptions, Evented) {\n\n  'use strict';\n\n  var Schema = objects.Class.extend({\n    init: function(options) {\n      options = options || {};\n      // model defaults\n      if (options.modelDefaults) {\n        this.modelDefaults = options.modelDefaults;\n      } else {\n        this.modelDefaults = {\n          keys: {\n            'id': {primaryKey: true, defaultValue: uuid.uuid}\n          }\n        };\n      }\n      // inflection\n      if (options.pluralize) {\n        this.pluralize = options.pluralize;\n      }\n      if (options.singularize) {\n        this.singularize = options.singularize;\n      }\n\n      Evented['default'].extend(this);\n\n      // register provided model schema\n      this.models = {};\n      if (options.models) {\n        for (var model in options.models) {\n          if (options.models.hasOwnProperty(model)) {\n            this.registerModel(model, options.models[model]);\n          }\n        }\n      }\n    },\n\n    /**\n     Registers a model's schema definition.\n\n     Emits the `modelRegistered` event upon completion.\n\n     @param {String} model      name of the model\n     @param {Object} definition model schema definition\n     */\n    registerModel: function(model, definition) {\n      var modelSchema = this._mergeModelSchemas({}, this.modelDefaults, definition);\n\n      // process key definitions\n      for (var name in modelSchema.keys) {\n        var key = modelSchema.keys[name];\n\n        key.name = name;\n\n        if (key.primaryKey) {\n          if (modelSchema.primaryKey) {\n            throw new exceptions.OperationNotAllowed('Schema can only define one primaryKey per model');\n          }\n          modelSchema.primaryKey = key;\n\n        } else {\n          key.primaryKey = false;\n\n          key.secondaryToPrimaryKeyMap = {};\n          key.primaryToSecondaryKeyMap = {};\n\n          modelSchema.secondaryKeys = modelSchema.secondaryKeys || {};\n          modelSchema.secondaryKeys[name] = key;\n        }\n\n        key.type = key.type || 'string';\n        if (key.type !== 'string') {\n          throw new exceptions.OperationNotAllowed('Model keys must be of type `\"string\"`');\n        }\n      }\n\n      // ensure every model has a valid primary key\n      if (!modelSchema.primaryKey || typeof modelSchema.primaryKey.defaultValue !== 'function') {\n        throw new exceptions.OperationNotAllowed('Model schema ID defaultValue must be a function');\n      }\n\n      this.models[model] = modelSchema;\n\n      this.emit('modelRegistered', model);\n    },\n\n    /**\n     Normalizes a record according to its type and corresponding schema\n     definition.\n\n     A record's primary key, links, and meta data will all be initialized.\n\n     A record can only be normalized once. A flag is set on the record\n     (`__normalized`) to prevent \"re-normalization\".\n\n     @param  {String} model   record type\n     @param  {Object} data    record data\n     @return {Object} normalized version of `data`\n     */\n    normalize: function(model, data) {\n      if (data.__normalized) return data;\n\n      var record = data;\n\n      // set flag\n      record.__normalized = true;\n\n      // init backward links\n      record.__rev = record.__rev || {};\n\n      // init forward links\n      record.__rel = record.__rel || {};\n\n      // init meta info\n      record.__meta = record.__meta || {};\n\n      this.initDefaults(model, record);\n\n      return record;\n    },\n\n    initDefaults: function(model, record) {\n      if (!record.__normalized) {\n        throw new exceptions.OperationNotAllowed('Schema.initDefaults requires a normalized record');\n      }\n\n      var modelSchema = this.models[model],\n          keys = modelSchema.keys,\n          attributes = modelSchema.attributes,\n          links = modelSchema.links;\n\n      // init primary key - potentially setting the primary key from secondary keys if necessary\n      this._initPrimaryKey(modelSchema, record);\n\n      // init default key values\n      for (var key in keys) {\n        if (record[key] === undefined) {\n          record[key] = this._defaultValue(record, keys[key].defaultValue, null);\n        }\n      }\n\n      // init default attribute values\n      if (attributes) {\n        for (var attribute in attributes) {\n          if (record[attribute] === undefined) {\n            record[attribute] = this._defaultValue(record, attributes[attribute].defaultValue, null);\n          }\n        }\n      }\n\n      // init default link values\n      if (links) {\n        for (var link in links) {\n          if (record.__rel[link] === undefined) {\n            record.__rel[link] = this._defaultValue(record,\n                                                    links[link].defaultValue,\n                                                    links[link].type === 'hasMany' ? {} : null);\n          }\n        }\n      }\n\n      this._mapKeys(modelSchema, record);\n    },\n\n    primaryToSecondaryKey: function(model, secondaryKeyName, primaryKeyValue, autoGenerate) {\n      var modelSchema = this.models[model];\n      var secondaryKey = modelSchema.keys[secondaryKeyName];\n\n      var value = secondaryKey.primaryToSecondaryKeyMap[primaryKeyValue];\n\n      // auto-generate secondary key if necessary, requested, and possible\n      if (value === undefined && autoGenerate && secondaryKey.defaultValue) {\n        value = secondaryKey.defaultValue();\n        this._registerKeyMapping(secondaryKey, primaryKeyValue, value);\n      }\n\n      return value;\n    },\n\n    secondaryToPrimaryKey: function(model, secondaryKeyName, secondaryKeyValue, autoGenerate) {\n      var modelSchema = this.models[model];\n      var secondaryKey = modelSchema.keys[secondaryKeyName];\n\n      var value = secondaryKey.secondaryToPrimaryKeyMap[secondaryKeyValue];\n\n      // auto-generate primary key if necessary, requested, and possible\n      if (value === undefined && autoGenerate && modelSchema.primaryKey.defaultValue) {\n        value = modelSchema.primaryKey.defaultValue();\n        this._registerKeyMapping(secondaryKey, value, secondaryKeyValue);\n      }\n\n      return value;\n    },\n\n    /**\n     Given a data object structured according to this schema, register all of its\n     primary and secondary key mappings. This data object may contain any number\n     of records and types.\n\n     @param {Object} data - data structured according to this schema\n     */\n    registerAllKeys: function(data) {\n      if (data) {\n        Object.keys(data).forEach(function(type) {\n          var modelSchema = this.models[type];\n\n          if (modelSchema && modelSchema.secondaryKeys) {\n            var records = data[type];\n\n            Object.keys(records).forEach(function(id) {\n              var record = records[id];\n              var altId;\n\n              Object.keys(modelSchema.secondaryKeys).forEach(function(secondaryKey) {\n                altId = record[secondaryKey];\n                if (altId !== undefined && altId !== null) {\n                  var secondaryKeyDef = modelSchema.secondaryKeys[secondaryKey];\n                  this._registerKeyMapping(secondaryKeyDef, id, altId);\n                }\n              }, this);\n            }, this);\n          }\n        }, this);\n      }\n    },\n\n    /**\n     A naive pluralization method.\n\n     Override with a more robust general purpose inflector or provide an\n     inflector tailored to the vocabularly of your application.\n\n     @param  {String} word\n     @return {String} plural form of `word`\n     */\n    pluralize: function(word) {\n      return word + 's';\n    },\n\n    /**\n     A naive singularization method.\n\n     Override with a more robust general purpose inflector or provide an\n     inflector tailored to the vocabularly of your application.\n\n     @param  {String} word\n     @return {String} singular form of `word`\n     */\n    singularize: function(word) {\n      if (word.lastIndexOf('s') === word.length - 1) {\n        return word.substr(0, word.length - 1);\n      } else {\n        return word;\n      }\n    },\n\n    _defaultValue: function(record, value, defaultValue) {\n      if (value === undefined) {\n        return defaultValue;\n\n      } else if (typeof value === 'function') {\n        return value.call(record);\n\n      } else {\n        return value;\n      }\n    },\n\n    _initPrimaryKey: function(modelSchema, record) {\n      var pk = modelSchema.primaryKey.name;\n      var id = record[pk];\n\n      // init primary key from secondary keys\n      if (!id && modelSchema.secondaryKeys) {\n        var keyNames = Object.keys(modelSchema.secondaryKeys);\n        for (var i=0, l = keyNames.length; i <l ; i++){\n          var key = modelSchema.keys[keyNames[i]];\n          var value = record[key.name];\n          if (value) {\n            id = key.secondaryToPrimaryKeyMap[value];\n            if (id) {\n              record[pk] = id;\n              return;\n            }\n          }\n        }\n      }\n    },\n\n    _mapKeys: function(modelSchema, record) {\n      var id = record[modelSchema.primaryKey.name];\n\n      if (modelSchema.secondaryKeys) {\n        Object.keys(modelSchema.secondaryKeys).forEach(function(name) {\n          var value = record[name];\n          if (value) {\n            var key = modelSchema.secondaryKeys[name];\n            this._registerKeyMapping(key, id, value);\n          }\n        }, this);\n      }\n    },\n\n    _registerKeyMapping: function(secondaryKeyDef, primaryValue, secondaryValue) {\n      secondaryKeyDef.primaryToSecondaryKeyMap[primaryValue] = secondaryValue;\n      secondaryKeyDef.secondaryToPrimaryKeyMap[secondaryValue] = primaryValue;\n    },\n\n    _mergeModelSchemas: function(base) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n\n      // ensure model schema has categories set\n      base.keys = base.keys || {};\n      base.attributes = base.attributes || {};\n      base.links = base.links || {};\n\n      sources.forEach(function(source) {\n        source = objects.clone(source);\n        this._mergeModelFields(base.keys, source.keys);\n        this._mergeModelFields(base.attributes, source.attributes);\n        this._mergeModelFields(base.links, source.links);\n      }, this);\n\n      return base;\n    },\n\n    _mergeModelFields: function(base, source) {\n      if (source) {\n        Object.keys(source).forEach(function(field) {\n          if (source.hasOwnProperty(field)) {\n            var fieldDef = source[field];\n            if (fieldDef) {\n              base[field] = fieldDef;\n            } else {\n              // fields defined as falsey should be removed\n              delete base[field];\n            }\n          }\n        });\n      }\n    }\n  });\n\n  exports['default'] = Schema;\n\n});","define('orbit-common/serializer', ['exports', 'orbit/lib/objects', 'orbit/lib/stubs'], function (exports, objects, stubs) {\n\n  'use strict';\n\n  var Serializer = objects.Class.extend({\n    init: function(schema) {\n      this.schema = schema;\n    },\n\n    serialize: stubs.required,\n\n    deserialize: stubs.required\n  });\n\n  exports['default'] = Serializer;\n\n});","define('orbit-common/source', ['exports', 'orbit/main', 'orbit/document', 'orbit/transformable', 'orbit/requestable', 'orbit/lib/assert', 'orbit/lib/stubs', 'orbit/lib/objects', 'orbit-common/cache', 'orbit/operation'], function (exports, Orbit, Document, Transformable, Requestable, assert, stubs, objects, Cache, Operation) {\n\n  'use strict';\n\n  var Source = objects.Class.extend({\n    init: function(schema, options) {\n      assert.assert(\"Source's `schema` must be specified\", schema);\n\n      this.schema = schema;\n\n      options = options || {};\n\n      // Create an internal cache and expose some elements of its interface\n      this._cache = new Cache['default'](schema);\n      objects.expose(this, this._cache,\n             'length', 'reset', 'retrieve', 'retrieveLink',\n             '_addLinkOp', '_removeLinkOp', '_updateLinkOp');\n      // TODO - clean up listener\n      this._cache.on('didTransform', this._cacheDidTransform, this);\n\n      Transformable['default'].extend(this);\n      Requestable['default'].extend(this, ['find', 'add', 'update', 'patch', 'remove',\n                                'findLink', 'addLink', 'removeLink', 'updateLink',\n                                'findLinked']);\n\n      Source.created(this);\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Transformable interface implementation\n    /////////////////////////////////////////////////////////////////////////////\n\n    /**\n     Internal method that applies a single transform to this source.\n\n     `_transform` must be implemented by a `Transformable` source.\n     It is called by the public method `transform` in order to actually apply\n     transforms.\n\n     `_transform` should return a promise if the operation is asynchronous.\n\n     @method _transform\n     @param operation JSON PATCH operation as detailed in RFC 6902\n     @private\n     */\n    _transform: stubs.required,\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Requestable interface implementation\n    /////////////////////////////////////////////////////////////////////////////\n\n    _find: stubs.required,\n\n    _findLink: stubs.required,\n\n    _findLinked: function(type, id, link, relId) {\n      var _this = this;\n      var linkDef = _this.schema.models[type].links[link];\n      var relType = linkDef.model;\n\n      id = this.getId(type, id);\n\n      if (relId === undefined) {\n        relId = this.retrieveLink(type, id, link);\n      }\n\n      if (this._isLinkEmpty(linkDef.type, relId)) {\n        return new Orbit['default'].Promise(function(resolve) {\n          resolve(relId);\n        });\n\n      } else if (relId) {\n        return this.find(relType, relId);\n\n      } else {\n        return this.findLink(type, id, link).then(function(relId) {\n          if (_this._isLinkEmpty(linkDef.type, relId)) {\n            return relId;\n          } else {\n            return _this.find(relType, relId);\n          }\n        });\n      }\n    },\n\n    _add: function(type, data) {\n      data = data || {};\n\n      var record = this.normalize(type, data);\n\n      var id = this.getId(type, record),\n          path = [type, id],\n          _this = this;\n\n      return this.transform({op: 'add', path: path, value: record}).then(function() {\n        return _this.retrieve(path);\n      });\n    },\n\n    _update: function(type, data) {\n      var record = this.normalize(type, data);\n      var id = this.getId(type, record);\n      var path = [type, id];\n\n      return this.transform({op: 'replace', path: path, value: record});\n    },\n\n    _patch: function(type, id, property, value) {\n      id = this._normalizeId(type, id);\n      var path = [type, id].concat(Document['default'].prototype.deserializePath(property));\n\n      return this.transform({op: 'replace', path: path, value: value});\n    },\n\n    _remove: function(type, id) {\n      id = this._normalizeId(type, id);\n      var path = [type, id];\n\n      return this.transform({op: 'remove', path: path});\n    },\n\n    _addLink: function(type, id, key, value) {\n      id = this._normalizeId(type, id);\n      value = this._normalizeLink(type, key, value);\n\n      return this.transform(this._addLinkOp(type, id, key, value));\n    },\n\n    _removeLink: function(type, id, key, value) {\n      id = this._normalizeId(type, id);\n      value = this._normalizeLink(type, key, value);\n\n      return this.transform(this._removeLinkOp(type, id, key, value));\n    },\n\n    _updateLink: function(type, id, key, value) {\n      var linkDef = this.schema.models[type].links[key];\n\n      assert.assert('hasMany links can only be replaced when flagged as `actsAsSet`',\n             linkDef.type !== 'hasMany' || linkDef.actsAsSet);\n\n      id = this._normalizeId(type, id);\n      value = this._normalizeLink(type, key, value);\n\n      var op = this._updateLinkOp(type, id, key, value);\n      return this.transform(op);\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Event handlers\n    /////////////////////////////////////////////////////////////////////////////\n\n    _cacheDidTransform: function(operation, inverse) {\n      this.didTransform(operation, inverse);\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Helpers\n    /////////////////////////////////////////////////////////////////////////////\n\n    _normalizeId: function(type, id) {\n      if (objects.isObject(id)) {\n        var record = this.normalize(type, id);\n        id = this.getId(type, record);\n      }\n      return id;\n    },\n\n    _normalizeLink: function(type, key, value) {\n      if (objects.isObject(value)) {\n        var linkDef = this.schema.models[type].links[key];\n        var relatedRecord;\n\n        if (objects.isArray(value)) {\n          for (var i = 0, l = value.length; i < l; i++) {\n            if (objects.isObject(value[i])) {\n              relatedRecord = this.normalize(linkDef.model, value[i]);\n              value[i] = this.getId(linkDef.model, relatedRecord);\n            }\n          }\n\n        } else {\n          relatedRecord = this.normalize(linkDef.model, value);\n          value = this.getId(linkDef.model, relatedRecord);\n        }\n      }\n      return value;\n    },\n\n    normalize: function(type, data) {\n      return this.schema.normalize(type, data);\n    },\n\n    initDefaults: function(type, record) {\n      return this.schema.initDefaults(type, record);\n    },\n\n    getId: function(type, data) {\n      if (objects.isObject(data)) {\n        return data[this.schema.models[type].primaryKey.name];\n      } else {\n        return data;\n      }\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Internals\n    /////////////////////////////////////////////////////////////////////////////\n\n    _isLinkEmpty: function(linkType, linkValue) {\n      return (linkType === 'hasMany' && linkValue && linkValue.length === 0 ||\n              linkType === 'hasOne' && objects.isNone(linkValue));\n    }\n  });\n\n  /**\n   * A place to track the creation of any Source, is called in the Source init\n   * method.  The source might not be fully configured / setup by the time you\n   * receive it, but we provide this hook for potential debugging tools to monitor\n   * all sources.\n   *\n   * @namespace OC\n   * @param {OC.Source} source The newly forged Source.\n   */\n  Source.created = function(/* source */) {};\n\n  exports['default'] = Source;\n\n});"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","file":"orbit-common.amd.js"}